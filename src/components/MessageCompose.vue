<template>
  <div class="card mb-4 compose">
    <div class="card-body">
      <form @submit.prevent="submit()">
        <div v-if="createChannelMode" class="form-group">
          <div
            :class="{
              'd-flex justify-content-between align-items-center': calcPmLookup,
            }"
          >
            <input
              v-model="channelUsersStr"
              type="text"
              class="form-control"
              placeholder="usernames (comma or space delimited)"
              @input="resetPmSearch"
            />
            <button
              v-if="calcPmLookup && !targetUser"
              :disabled="pmLookupStatus"
              type="button"
              class="ml-3 btn text-uppercase btn-primary"
              @click="findExistingPm"
            >
              <span v-show="promise">
                <font-awesome-icon class="mr-2" icon="sync" spin fixed-width />
              </span>
              <font-awesome-icon icon="search" class="mr-2" />
              {{ pmLookupStatus ? pmLookupStatus : 'Find Existing' }}
            </button>
          </div>
        </div>
        <div class="form-group">
          <textarea
            ref="textarea"
            v-model="text"
            :disabled="promise"
            class="form-control"
            data-test-id="textarea"
            @keydown.ctrl.enter="submit()"
            @keydown.meta.enter="submit()"
          />
        </div>
        <div v-show="photos.length" class="form-group">
          <transition-group
            tag="div"
            name="photos"
            class="d-flex flex-wrap justify-content align-items-center"
          >
            <thumb
              v-for="(photo, i) in previewPhotos"
              :key="photo.data"
              :original="photo.data"
              :thumb="photo.data"
              removable
              class="mr-2"
              @remove="photos.splice(i, 1)"
            />
          </transition-group>
        </div>
        <div class="d-flex justify-content-between align-items-center">
          <span data-test-id="message-counter">
            {{ remain }}
          </span>
          <div>
            <label
              v-show="!noPhoto"
              v-if="storage.available"
              :disabled="promise"
              class="btn btn-link text-dark add-photo mr-3"
            >
              <font-awesome-icon :icon="['far', 'image']" />
              <span class="d-none d-sm-inline ml-2">
                Photo
              </span>
              <input
                ref="file"
                type="file"
                multiple
                accept="image/*"
                style="display: none;"
                @change="fileChange"
              />
            </label>
            <button
              :class="{
                'text-dark': !hasSpoiler,
                'btn-primary': hasSpoiler,
              }"
              class="btn btn-link add-spoiler mr-3"
              type="button"
              @click="toggleSpoiler"
            >
              <font-awesome-icon :icon="['far', 'bell']" />
              <span class="d-none d-sm-inline ml-2">
                Spoiler
              </span>
            </button>
            <span :class="{ 'btn-group': canBroadcast }">
              <button
                :disabled="calcDisabled"
                type="submit"
                data-test-id="submitButton"
                class="ml-1 btn text-uppercase btn-primary"
              >
                <span v-show="promise && !calcPmLookup">
                  <font-awesome-icon
                    icon="sync"
                    spin
                    fixed-width
                    class="mr-2"
                  />
                </span>
                <span>Send</span>
              </button>
              <button
                v-if="canBroadcast"
                ref="dropdown"
                :disabled="calcDisabled"
                data-test-id="broadcastButton"
                type="button"
                class="btn btn-danger dropdown-toggle dropdown-toggle-split"
                data-toggle="dropdown"
                aria-haspopup="true"
                aria-expanded="false"
              >
                <span class="sr-only">
                  Toggle Dropdown
                </span>
              </button>
              <div class="dropdown-menu dropdown-menu-right">
                <a
                  data-test-id="broadcast"
                  class="dropdown-item"
                  href="#"
                  @click.prevent="broadcast"
                >
                  Broadcast
                </a>
              </div>
            </span>
          </div>
        </div>
        <input-spoiler
          v-if="spoiler"
          class="mt-3"
          @update:spoiler="(p) => (spoiler = p)"
        />
      </form>
    </div>
  </div>
</template>
<script lang="ts">
import Vue, { PropOptions } from 'vue'
import unicodeSubstring from 'unicode-substring'
import { Dropdown } from 'bootstrap.native'
import bus from '../assets/ts/bus'
import textCount from '~/assets/ts/text-count'
import Thumb from '~/components/Thumb.vue'
import InputSpoiler from '~/components/InputSpoiler.vue'
import resettable from '~/assets/ts/resettable'
import { Spoiler } from '~/models/raw/raw/spoiler'
import { Channel } from '~/models/channel'
import { Token } from '~/models/token'
import { Raw } from '~/models/raw'
import { PnutResponse } from '~/models/pnut-response'
import { getMinimumSpoiler } from '~/util/minimum-entities'

function obj2FormData(obj: { [key: string]: string | Blob }) {
  return Object.keys(obj).reduce((fd, key) => {
    fd.append(key, obj[key])
    return fd
  }, new FormData())
}

export default Vue.extend({
  components: {
    Thumb,
    InputSpoiler,
  },
  mixins: [textCount, resettable],
  props: {
    createChannelMode: {
      type: Boolean,
      default: false,
    },
    noPhoto: {
      type: Boolean,
      default: false,
    },
    targetUser: {
      type: String,
      default: '',
    },
    channel: {
      type: Object,
      default: null,
    } as PropOptions<Channel>,
  },
  data() {
    return {
      // TODO
      promise: null as Promise<PnutResponse<any>> | null | boolean,
      channelUsersStr: '',
      text: '',
      photos: [] as File[],
      previewPhotos: [] as string[],
      spoiler: null as Spoiler.Value | null,
      pmLookupStatus: null as string | null,
      dropdown: null as Dropdown | null,
    }
  },
  computed: {
    canBroadcast(): boolean {
      return this.channel && this.channel.acl.read.public
    },
    calcDisabled(): boolean {
      const requireTargetValue = this.createChannelMode && !this.channelUsersStr
      return (
        requireTargetValue ||
        !!this.promise ||
        !this.text ||
        this.remain < 0 ||
        (!!this.spoiler && !this.availableSpoiler)
      )
    },
    calcPmLookup(): boolean {
      return this.createChannelMode && !!this.channelUsersStr && !this.text
    },
    remain(): number {
      // TODO
      return 2048 - (this as any).textLength
    },
    hasPhotos(): boolean {
      return !!this.photos.length
    },
    hasSpoiler(): boolean {
      return !!this.spoiler
    },
    availableSpoiler(): boolean {
      return (
        !!this.spoiler &&
        !!this.spoiler.topic &&
        this.spoiler.topic.length > 0 &&
        this.spoiler.topic.length <= 128
      )
    },
    storage(): Token.Storage {
      return this.$store.getters.storage
    },
  },
  watch: {
    async photos() {
      const promisePhotos = this.photos.map((file) => {
        return new Promise<string>((resolve, reject) => {
          const fr = new FileReader()
          fr.readAsDataURL(file)
          fr.onload = (e) => {
            if (
              !e.target ||
              !e.target.result ||
              typeof e.target.result !== 'string'
            )
              return reject(new Error('Failed to load photo'))
            resolve(e.target.result)
          }
        })
      })
      this.previewPhotos = await Promise.all(promisePhotos)
    },
    targetUser(user) {
      this.channelUsersStr = user
    },
  },
  mounted() {
    this.$mousetrap.bind('n', (e) => {
      ;(this.$refs.textarea as any).focus()
      e.preventDefault()
    })
    if (!this.$refs.dropdown) return
    this.dropdown = new Dropdown(this.$refs.dropdown as Element)
  },
  beforeDestroy() {
    this.$mousetrap.unbind('n')
  },
  methods: {
    async broadcast() {
      const option = await this.createGeneralPost()
      const raw: Raw<any>[] = [
        {
          type: 'io.pnut.core.crosspost',
          value: {
            // TODO: use rel="canonical" value in the future
            canonical_url: location.href,
          },
        },
        {
          type: 'io.pnut.core.channel.invite',
          value: {
            channel_id: this.channel.id,
          },
        },
      ]
      option.raw.push(...raw)
      option.text = `${unicodeSubstring(this.text, 0, 255)}â€¦`
      const res = await this.$axios.$post('/posts', option)
      this.promise = true
      await this.submit(option)
      return res
    },
    toggleSpoiler() {
      this.spoiler = this.spoiler ? null : getMinimumSpoiler()
    },
    resetPmSearch() {
      this.pmLookupStatus = null
    },
    async findExistingPm() {
      this.pmLookupStatus = 'Searching'
      try {
        const destinations = this.channelUsersStr
          .split(/[,\s]+/g)
          .map((name) => {
            return name.startsWith('@') ? name : `@${name}`
          })
        this.promise = this.$axios.$get(
          `/users/me/channels/existing_pm?ids=${destinations.join(',')}`
        )
        const { data: channel } = await this.promise
        if (channel) {
          this.$router.push(`/messages/${channel.id}`)
          this.$emit('foundChannel')
        } else {
          this.pmLookupStatus = 'Not Found'
        }
      } catch (e) {
        this.pmLookupStatus = 'Not Found'
      }
      this.promise = null
    },
    async createGeneralPost() {
      const option = {
        text: this.text,
        raw: [] as Raw<any>[],
      }
      if (this.hasPhotos) {
        const raws = await this.uploadPhotos()
        option.raw.push(...raws)
      }
      if (this.spoiler) {
        option.raw.push({
          type: 'shawn.spoiler',
          value: {
            topic: this.spoiler.topic,
          },
        })
      }
      return option
    },
    async submit(
      preparedOption: {
        text: string
        raw: Raw<any>[]
      } | null = null
    ) {
      if (this.createChannelMode) return this.createChannel()
      try {
        const option = preparedOption || (await this.createGeneralPost())
        option.text = this.text
        this.promise = this.$axios.$post(
          `/channels/${this.$route.params.channel}/messages?update_marker=1`,
          option
        )
        const { meta } = await this.promise
        if (meta.code === 201) {
          this.$emit('submit')
        }
        bus.$emit('post')
        this.text = ''
        this.$toast.success('Posted!')
        this.photos = []
        this.spoiler = null
      } catch (e) {
        console.error(e)
        this.$toast.error(e.message)
      }
      this.promise = null
    },
    async createChannel() {
      const destinations = this.channelUsersStr.split(/[,\s]+/g).map((name) => {
        return name.startsWith('@') ? name : `@${name}`
      })
      const option = {
        text: this.text,
        destinations,
      }
      const { data: channel } = await this.$axios.$post(
        '/channels/pm/messages',
        option
      )
      this.channelUsersStr = ''
      this.text = ''
      this.photos = []
      this.$router.push(`/messages/${channel.channel_id}`)
      this.$emit('submit')
    },
    async uploadPhotos() {
      const photosPromise = this.photos.map(async (content) => {
        const data = obj2FormData({
          type: 'net.unsweets.beta',
          name: content.name,
          kind: 'image',
          content,
          is_public: 'false',
        })
        const res = await this.$axios.$post('/files', data, {
          headers: {
            'Content-type': 'multipart/form-data',
          },
        })
        return res
      })
      this.promise = true
      const photosJson = await Promise.all(photosPromise)
      const raws = photosJson.map((res) => {
        const image = res.data
        const value = {
          '+io.pnut.core.file': {
            file_id: image.id,
            file_token: image.file_token,
            format: 'oembed',
          },
        }
        return Object.assign(
          {},
          {
            type: 'io.pnut.core.oembed',
          },
          { value }
        )
      })
      return raws
    },
    fileChange(e: Event) {
      if (!e.target) return
      const inputEl = e.target as HTMLInputElement
      if (!inputEl || !inputEl.files || !inputEl.files.length) return
      const files = inputEl.files
      const filesAry = Array.from(files)
      // filesAry
      this.photos = [...this.photos, ...filesAry] as File[]
      // reset file form for detecting changes(if there `sn't below code, not working when is selected same file)
      ;(this.$refs.file as any).value = ''
    },
  },
})
</script>

<style scoped lang="scss">
@import '~assets/css/mixin';

.compose {
  @include no-gutter-xs;
}
textarea {
  min-height: 5rem;
}
.add-photo {
  cursor: pointer;
  margin-bottom: 0;
}
</style>
